"""Vulnerability analysis API routes."""

import logging
from typing import Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field, validator

from ...models.vulnerability import (
    VulnerabilityReport,
)
from ...utils.network_utils import validate_network

logger = logging.getLogger(__name__)

router = APIRouter()


# Request/Response models
class VulnerabilityScanRequest(BaseModel):
    """Request model for vulnerability scanning."""

    contract_addresses: list[str] = Field(..., description="List of contract addresses to scan")
    networks: list[str] = Field(..., description="Networks where contracts are deployed")
    scan_type: str = Field(
        default="comprehensive", description="Type of scan: basic, comprehensive, deep"
    )
    include_deep_analysis: bool = Field(default=True, description="Include deep analysis")
    analyze_bridge_risks: bool = Field(default=True, description="Analyze bridge-specific risks")
    check_governance: bool = Field(default=True, description="Check governance vulnerabilities")

    @validator("contract_addresses")
    def validate_contract_addresses(cls, v):
        if not v:
            raise ValueError("At least one contract address is required")
        for address in v:
            if not address.startswith("0x") or len(address) != 42:
                raise ValueError(f"Invalid contract address format: {address}")
        return [addr.lower() for addr in v]

    @validator("networks")
    def validate_networks(cls, v):
        if not v:
            raise ValueError("At least one network is required")
        for network in v:
            if not validate_network(network):
                raise ValueError(f"Unsupported network: {network}")
        return v

    @validator("scan_type")
    def validate_scan_type(cls, v):
        if v not in ["basic", "comprehensive", "deep"]:
            raise ValueError("Scan type must be: basic, comprehensive, or deep")
        return v


class CrossChainVulnerabilityRequest(BaseModel):
    """Request model for cross-chain vulnerability analysis."""

    contracts: list[dict[str, str]] = Field(
        ..., description="List of contracts with addresses and networks"
    )
    analysis_options: dict[str, Any] = Field(
        default_factory=lambda: {
            "deep_analysis": True,
            "bridge_risk_analysis": True,
            "governance_analysis": True,
            "interoperability_check": True,
            "security_assessment": True,
        },
        description="Analysis options",
    )

    @validator("contracts")
    def validate_contracts(cls, v):
        if not v:
            raise ValueError("At least one contract is required")
        for contract in v:
            if "address" not in contract or "network" not in contract:
                raise ValueError("Each contract must have address and network")
            if not contract["address"].startswith("0x") or len(contract["address"]) != 42:
                raise ValueError(f'Invalid contract address format: {contract["address"]}')
            if not validate_network(contract["network"]):
                raise ValueError(f'Unsupported network: {contract["network"]}')
        return v


class ThreatIntelligenceRequest(BaseModel):
    """Request model for threat intelligence."""

    networks: list[str] | None = Field(None, description="Specific networks to analyze")
    threat_types: list[str] | None = Field(None, description="Types of threats to focus on")
    time_range: str = Field(default="7d", description="Time range for threat analysis")

    @validator("networks")
    def validate_networks(cls, v):
        if v:
            for network in v:
                if not validate_network(network):
                    raise ValueError(f"Unsupported network: {network}")
        return v


@router.post("/scan", response_model=VulnerabilityReport)
async def scan_vulnerabilities(request: VulnerabilityScanRequest):
    """
    Scan contracts for security vulnerabilities.

    This endpoint performs comprehensive vulnerability scanning on multiple
    contracts across different networks, identifying security issues and
    providing detailed remediation recommendations.
    """
    try:
        logger.info(f"Starting vulnerability scan for {len(request.contract_addresses)} contracts")

        # Mock vulnerability scanning
        vulnerabilities = []

        # Generate mock vulnerabilities based on scan type
        if request.scan_type in ["comprehensive", "deep"]:
            vulnerabilities.extend(
                [
                    {
                        "id": "vuln_001",
                        "type": "reentrancy",
                        "severity": "high",
                        "title": "Potential Reentrancy Vulnerability",
                        "description": "Contract uses external calls without reentrancy protection",
                        "affected_contracts": request.contract_addresses[:1],
                        "affected_networks": request.networks[:1],
                        "cwe_id": "CWE-841",
                        "cvss_score": 7.5,
                        "exploitability": "high",
                        "impact": "high",
                        "file_path": "contracts/Bridge.sol",
                        "line_number": 45,
                        "function_name": "deposit",
                        "detection_method": "static_analysis",
                        "remediation": "Implement ReentrancyGuard modifier",
                        "references": [
                            "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
                        ],
                        "cross_chain_impact": "High - affects cross-chain operations",
                        "bridge_affected": True,
                        "propagation_risk": "medium",
                    },
                    {
                        "id": "vuln_002",
                        "type": "access_control",
                        "severity": "medium",
                        "title": "Insufficient Access Control",
                        "description": "Critical functions lack proper access control mechanisms",
                        "affected_contracts": request.contract_addresses[:2],
                        "affected_networks": request.networks,
                        "cwe_id": "CWE-284",
                        "cvss_score": 6.0,
                        "exploitability": "medium",
                        "impact": "high",
                        "file_path": "contracts/Governance.sol",
                        "line_number": 78,
                        "function_name": "emergencyPause",
                        "detection_method": "static_analysis",
                        "remediation": "Implement proper access control modifiers",
                        "references": [
                            "https://consensys.github.io/smart-contract-best-practices/access-control/"
                        ],
                        "cross_chain_impact": "Medium - affects governance operations",
                        "bridge_affected": False,
                        "propagation_risk": "low",
                    },
                ]
            )

        if request.scan_type == "deep":
            vulnerabilities.append(
                {
                    "id": "vuln_003",
                    "type": "bridge_specific",
                    "severity": "critical",
                    "title": "Cross-Chain Finality Risk",
                    "description": "Bridge does not properly validate finality across chains",
                    "affected_contracts": request.contract_addresses,
                    "affected_networks": request.networks,
                    "cwe_id": "CWE-362",
                    "cvss_score": 9.0,
                    "exploitability": "high",
                    "impact": "critical",
                    "file_path": "contracts/CrossChainBridge.sol",
                    "line_number": 123,
                    "function_name": "processWithdrawal",
                    "detection_method": "cross_chain_analysis",
                    "remediation": "Implement proper finality checks and time locks",
                    "references": ["https://ethereum.org/en/developers/docs/bridges/risks/"],
                    "cross_chain_impact": "Critical - affects all cross-chain operations",
                    "bridge_affected": True,
                    "propagation_risk": "high",
                }
            )

        # Calculate summary statistics
        total_vulnerabilities = len(vulnerabilities)
        critical_count = len([v for v in vulnerabilities if v["severity"] == "critical"])
        high_count = len([v for v in vulnerabilities if v["severity"] == "high"])
        medium_count = len([v for v in vulnerabilities if v["severity"] == "medium"])
        low_count = len([v for v in vulnerabilities if v["severity"] == "low"])

        # Calculate overall risk score
        risk_score = 0.0
        if total_vulnerabilities > 0:
            risk_score = (
                critical_count * 10 + high_count * 7 + medium_count * 4 + low_count * 1
            ) / total_vulnerabilities

        # Determine risk level
        if risk_score >= 8:
            risk_level = "critical"
        elif risk_score >= 6:
            risk_level = "high"
        elif risk_score >= 4:
            risk_level = "medium"
        elif risk_score >= 2:
            risk_level = "low"
        else:
            risk_level = "minimal"

        # Generate recommendations
        recommendations = []
        if critical_count > 0:
            recommendations.append("Address critical vulnerabilities immediately")
        if high_count > 0:
            recommendations.append("Prioritize high-severity vulnerabilities")
        if medium_count > 0:
            recommendations.append("Schedule medium-severity fixes")

        # Cross-chain specific analysis
        cross_chain_risks = []
        shared_vulnerabilities = []
        bridge_vulnerabilities = []

        if request.analyze_bridge_risks:
            cross_chain_risks = [
                {
                    "type": "finality_risk",
                    "severity": "high",
                    "description": "Different finality times between networks",
                    "affected_networks": request.networks,
                    "mitigation": "Implement proper finality validation",
                }
            ]

            bridge_vulnerabilities = [
                {
                    "type": "bridge_specific",
                    "severity": "medium",
                    "description": "Bridge-specific security considerations",
                    "affected_contracts": request.contract_addresses,
                    "recommendations": [
                        "Implement circuit breakers",
                        "Add multi-signature requirements",
                    ],
                }
            ]

        # Create vulnerability report
        report = VulnerabilityReport(
            report_id=f"scan_{hash(str(request.contract_addresses)) % 1000000:06d}",
            scan_timestamp="2024-01-01T12:00:00Z",
            scan_type=request.scan_type,
            target_contracts=request.contract_addresses,
            target_networks=request.networks,
            total_vulnerabilities=total_vulnerabilities,
            critical_count=critical_count,
            high_count=high_count,
            medium_count=medium_count,
            low_count=low_count,
            info_count=0,
            overall_risk_score=risk_score,
            risk_level=risk_level,
            security_recommendation=f"Overall risk level: {risk_level}. {'. '.join(recommendations)}",
            vulnerabilities=vulnerabilities,
            cross_chain_risks=cross_chain_risks,
            shared_vulnerabilities=shared_vulnerabilities,
            bridge_vulnerabilities=bridge_vulnerabilities,
            immediate_actions=recommendations[:2],
            short_term_recommendations=recommendations[2:4] if len(recommendations) > 2 else [],
            long_term_recommendations=[
                "Implement continuous security monitoring",
                "Regular security audits",
            ],
            scanner_version="1.0.0",
            scan_duration=30.5,
            scan_metadata={
                "scan_options": {
                    "include_deep_analysis": request.include_deep_analysis,
                    "analyze_bridge_risks": request.analyze_bridge_risks,
                    "check_governance": request.check_governance,
                },
                "networks_analyzed": len(request.networks),
                "contracts_analyzed": len(request.contract_addresses),
            },
        )

        logger.info(f"Vulnerability scan completed. Found {total_vulnerabilities} vulnerabilities")
        return report

    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error scanning vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.post("/cross-chain-scan")
async def scan_cross_chain_vulnerabilities(request: CrossChainVulnerabilityRequest):
    """
    Perform cross-chain vulnerability analysis.

    This endpoint analyzes vulnerabilities that affect multiple chains
    and identifies shared security risks across cross-chain deployments.
    """
    try:
        logger.info(
            f"Starting cross-chain vulnerability analysis for {len(request.contracts)} contracts"
        )

        # Mock cross-chain analysis
        analysis_result = {
            "analysis_id": f"cross_chain_{hash(str(request.contracts)) % 1000000:06d}",
            "analysis_timestamp": "2024-01-01T12:00:00Z",
            "contracts_analyzed": len(request.contracts),
            "networks_analyzed": len(set(contract["network"] for contract in request.contracts)),
            "total_risks": 5,
            "cross_chain_risks": [
                {
                    "type": "shared_vulnerability",
                    "severity": "high",
                    "title": "Shared Reentrancy Pattern",
                    "description": "Same reentrancy vulnerability pattern found across multiple chains",
                    "affected_contracts": [
                        contract["address"] for contract in request.contracts[:2]
                    ],
                    "affected_networks": [
                        contract["network"] for contract in request.contracts[:2]
                    ],
                    "risk_amplification": "High - vulnerability affects multiple chains simultaneously",
                    "recommendation": "Implement consistent reentrancy protection across all deployments",
                },
                {
                    "type": "bridge_interaction_risk",
                    "severity": "medium",
                    "title": "Inconsistent Bridge Validation",
                    "description": "Different validation logic across bridge implementations",
                    "affected_contracts": [contract["address"] for contract in request.contracts],
                    "affected_networks": [contract["network"] for contract in request.contracts],
                    "risk_amplification": "Medium - inconsistent behavior across chains",
                    "recommendation": "Standardize validation logic across all bridge implementations",
                },
            ],
            "shared_vulnerabilities": [
                {
                    "vulnerability_type": "access_control",
                    "severity": "medium",
                    "affected_contracts": [contract["address"] for contract in request.contracts],
                    "description": "Inconsistent access control patterns across chains",
                    "recommendation": "Implement standardized access control mechanisms",
                }
            ],
            "bridge_specific_risks": [
                {
                    "risk_type": "finality_risk",
                    "severity": "high",
                    "description": "Different finality requirements across networks",
                    "affected_networks": list(
                        set(contract["network"] for contract in request.contracts)
                    ),
                    "recommendation": "Implement adaptive finality validation based on network characteristics",
                }
            ],
            "risk_metrics": {
                "cross_chain_risk_score": 7.2,
                "isolated_risk_score": 5.8,
                "risk_amplification_factor": 1.24,
                "shared_vulnerability_count": 3,
                "bridge_vulnerability_count": 2,
            },
            "recommendations": {
                "immediate": [
                    "Address shared vulnerabilities across all chains",
                    "Implement consistent security patterns",
                ],
                "short_term": ["Standardize validation logic", "Implement cross-chain monitoring"],
                "long_term": [
                    "Develop cross-chain security framework",
                    "Implement automated cross-chain testing",
                ],
            },
            "analysis_metadata": {
                "analysis_options": request.analysis_options,
                "analysis_duration": 45.2,
                "networks_analyzed": list(
                    set(contract["network"] for contract in request.contracts)
                ),
                "contracts_analyzed": [contract["address"] for contract in request.contracts],
            },
        }

        logger.info("Cross-chain vulnerability analysis completed")
        return analysis_result

    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error analyzing cross-chain vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.get("/threats")
async def get_threat_intelligence(request: ThreatIntelligenceRequest = None):
    """
    Get cross-chain threat intelligence.

    This endpoint provides current threat intelligence including known
    attack vectors, emerging threats, and security recommendations.
    """
    try:
        logger.info("Getting cross-chain threat intelligence")

        # Mock threat intelligence
        threat_intelligence = {
            "timestamp": "2024-01-01T12:00:00Z",
            "time_range": request.time_range if request else "7d",
            "threat_level": "medium",
            "active_threats": [
                {
                    "threat_id": "threat_001",
                    "type": "bridge_exploit",
                    "severity": "high",
                    "title": "Cross-Chain Bridge Exploit Campaign",
                    "description": "Active exploitation campaign targeting cross-chain bridges",
                    "affected_networks": ["ethereum", "polygon", "bsc"],
                    "attack_vectors": ["reentrancy", "access_control_bypass"],
                    "indicators": [
                        "Unusual transaction patterns",
                        "Large value transfers",
                        "Multiple failed transactions",
                    ],
                    "mitigation": [
                        "Implement reentrancy guards",
                        "Add transaction limits",
                        "Monitor for suspicious patterns",
                    ],
                    "first_seen": "2024-01-01T00:00:00Z",
                    "last_updated": "2024-01-01T12:00:00Z",
                },
                {
                    "threat_id": "threat_002",
                    "type": "governance_attack",
                    "severity": "medium",
                    "title": "Governance Token Manipulation",
                    "description": "Attempts to manipulate governance tokens for bridge control",
                    "affected_networks": ["ethereum", "arbitrum"],
                    "attack_vectors": ["token_accumulation", "voting_power_manipulation"],
                    "indicators": [
                        "Rapid token accumulation",
                        "Unusual voting patterns",
                        "Large governance transactions",
                    ],
                    "mitigation": [
                        "Implement voting delays",
                        "Add token transfer limits",
                        "Monitor governance activity",
                    ],
                    "first_seen": "2024-01-01T06:00:00Z",
                    "last_updated": "2024-01-01T12:00:00Z",
                },
            ],
            "emerging_threats": [
                {
                    "threat_id": "emerging_001",
                    "type": "ai_attack",
                    "severity": "medium",
                    "title": "AI-Powered Bridge Exploitation",
                    "description": "Emerging use of AI to identify and exploit bridge vulnerabilities",
                    "affected_networks": ["all"],
                    "attack_vectors": ["automated_vulnerability_discovery", "pattern_analysis"],
                    "indicators": [
                        "Automated testing patterns",
                        "Systematic vulnerability probing",
                        "AI-generated attack payloads",
                    ],
                    "mitigation": [
                        "Implement rate limiting",
                        "Add behavioral analysis",
                        "Use AI for defense",
                    ],
                    "confidence": "medium",
                    "first_seen": "2024-01-01T10:00:00Z",
                }
            ],
            "security_recommendations": [
                {
                    "category": "immediate",
                    "recommendations": [
                        "Update all bridge contracts with latest security patches",
                        "Implement emergency pause mechanisms",
                        "Review and update access controls",
                    ],
                },
                {
                    "category": "short_term",
                    "recommendations": [
                        "Conduct comprehensive security audits",
                        "Implement cross-chain monitoring",
                        "Develop incident response procedures",
                    ],
                },
                {
                    "category": "long_term",
                    "recommendations": [
                        "Build automated security testing",
                        "Implement AI-powered threat detection",
                        "Develop cross-chain security standards",
                    ],
                },
            ],
            "threat_statistics": {
                "total_threats": 15,
                "active_threats": 3,
                "resolved_threats": 12,
                "threats_by_severity": {"critical": 1, "high": 2, "medium": 8, "low": 4},
                "threats_by_network": {
                    "ethereum": 8,
                    "polygon": 5,
                    "bsc": 4,
                    "arbitrum": 3,
                    "optimism": 2,
                },
            },
        }

        return threat_intelligence

    except Exception as e:
        logger.error(f"Error getting threat intelligence: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.get("/vulnerability-types")
async def get_vulnerability_types():
    """
    Get list of supported vulnerability types and their descriptions.

    This endpoint provides information about all vulnerability types
    that can be detected by the scanning system.
    """
    try:
        logger.info("Getting vulnerability types")

        vulnerability_types = [
            {
                "type": "reentrancy",
                "name": "Reentrancy",
                "description": "External calls that can be exploited to re-enter the contract",
                "severity_levels": ["critical", "high", "medium"],
                "common_impact": "Fund drainage, state manipulation",
                "detection_methods": ["static_analysis", "symbolic_execution"],
                "references": [
                    "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
                ],
            },
            {
                "type": "access_control",
                "name": "Access Control",
                "description": "Insufficient or missing access control mechanisms",
                "severity_levels": ["critical", "high", "medium", "low"],
                "common_impact": "Unauthorized access, privilege escalation",
                "detection_methods": ["static_analysis", "code_review"],
                "references": [
                    "https://consensys.github.io/smart-contract-best-practices/access-control/"
                ],
            },
            {
                "type": "integer_overflow",
                "name": "Integer Overflow/Underflow",
                "description": "Arithmetic operations that can overflow or underflow",
                "severity_levels": ["high", "medium"],
                "common_impact": "Unexpected behavior, fund manipulation",
                "detection_methods": ["static_analysis", "symbolic_execution"],
                "references": [
                    "https://consensys.github.io/smart-contract-best-practices/known_attacks/"
                ],
            },
            {
                "type": "bridge_specific",
                "name": "Bridge-Specific Vulnerabilities",
                "description": "Vulnerabilities specific to cross-chain bridge implementations",
                "severity_levels": ["critical", "high", "medium"],
                "common_impact": "Cross-chain fund loss, bridge manipulation",
                "detection_methods": ["cross_chain_analysis", "bridge_specific_checks"],
                "references": ["https://ethereum.org/en/developers/docs/bridges/risks/"],
            },
            {
                "type": "cross_chain",
                "name": "Cross-Chain Vulnerabilities",
                "description": "Vulnerabilities that affect multiple blockchain networks",
                "severity_levels": ["critical", "high", "medium"],
                "common_impact": "Multi-chain exploitation, systemic risk",
                "detection_methods": ["cross_chain_analysis", "pattern_matching"],
                "references": ["https://ethereum.org/en/developers/docs/bridges/risks/"],
            },
        ]

        return {
            "vulnerability_types": vulnerability_types,
            "total_types": len(vulnerability_types),
            "severity_levels": ["critical", "high", "medium", "low", "info"],
            "detection_methods": [
                "static_analysis",
                "dynamic_analysis",
                "symbolic_execution",
                "cross_chain_analysis",
                "bridge_specific_checks",
                "pattern_matching",
                "code_review",
            ],
        }

    except Exception as e:
        logger.error(f"Error getting vulnerability types: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
